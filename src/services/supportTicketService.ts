import { supabase } from '@/integrations/supabase/client';

export interface SupportTicket {
  id: string;
  ticket_number: string;
  user_id: string;
  user_email: string;
  user_name: string;
  subject: string;
  description: string;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  status: 'open' | 'in_progress' | 'resolved' | 'closed';
  assigned_to?: string;
  created_at: string;
  updated_at: string;
  closed_at: string | null;
  auto_close_at: string;
}

export interface SupportMessage {
  id: string;
  ticket_id: string;
  sender_id: string;
  sender_name: string;
  sender_type: 'client' | 'admin';
  message: string;
  created_at: string;
}

export interface CreateTicketData {
  subject: string;
  description: string;
  priority: 'low' | 'medium' | 'high' | 'urgent';
}

export interface SendMessageData {
  ticket_id: string;
  message: string;
}

export class SupportTicketService {
  
  static async createTicket(ticketData: CreateTicketData, userInfo: { id: string, email: string, name: string }): Promise<{ success: boolean; ticket?: SupportTicket; error?: string }> {
    try {
      const { data, error } = await supabase
        .from('support_tickets')
        .insert({
          user_id: userInfo.id,
          user_email: userInfo.email,
          user_name: userInfo.name,
          subject: ticketData.subject,
          description: ticketData.description,
          priority: ticketData.priority,
          status: 'open',
          ticket_number: '' // Will be auto-generated by trigger
        })
        .select()
        .single();

      if (error) throw error;

      return { success: true, ticket: data as SupportTicket };
    } catch (error: any) {
      console.error('Error creating ticket:', error);
      return { success: false, error: error.message };
    }
  }

  static async getUserTickets(): Promise<SupportTicket[]> {
    try {
      const { data, error } = await supabase
        .from('support_tickets')
        .select('*')
        .order('created_at', { ascending: false });

      if (error) throw error;

      return (data || []) as SupportTicket[];
    } catch (error) {
      console.error('Error fetching user tickets:', error);
      return [];
    }
  }

  static async getTicketMessages(ticketId: string): Promise<SupportMessage[]> {
    try {
      const { data, error } = await supabase
        .from('support_messages')
        .select('*')
        .eq('ticket_id', ticketId)
        .order('created_at', { ascending: true });

      if (error) throw error;

      return (data || []) as SupportMessage[];
    } catch (error) {
      console.error('Error fetching ticket messages:', error);
      return [];
    }
  }

  static async sendMessage(messageData: SendMessageData, userInfo: { id: string, name: string }): Promise<{ success: boolean; message?: SupportMessage; error?: string }> {
    try {
      const { data, error } = await supabase
        .from('support_messages')
        .insert({
          ticket_id: messageData.ticket_id,
          sender_id: userInfo.id,
          sender_name: userInfo.name,
          sender_type: 'client',
          message: messageData.message
        })
        .select()
        .single();

      if (error) throw error;

      return { success: true, message: data as SupportMessage };
    } catch (error: any) {
      console.error('Error sending message:', error);
      return { success: false, error: error.message };
    }
  }

  static async closeTicket(ticketId: string): Promise<{ success: boolean; error?: string }> {
    try {
      const { error } = await supabase
        .from('support_tickets')
        .update({
          status: 'closed',
          closed_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', ticketId);

      if (error) throw error;

      return { success: true };
    } catch (error: any) {
      console.error('Error closing ticket:', error);
      return { success: false, error: error.message };
    }
  }

  static async getTicketStats(): Promise<{ total: number; open: number; closed: number; inProgress: number }> {
    try {
      const { data, error } = await supabase
        .from('support_tickets')
        .select('status');

      if (error) throw error;

      const stats = {
        total: data?.length || 0,
        open: data?.filter(t => t.status === 'open').length || 0,
        closed: data?.filter(t => t.status === 'closed').length || 0,
        inProgress: data?.filter(t => t.status === 'in_progress').length || 0
      };

      return stats;
    } catch (error) {
      console.error('Error fetching ticket stats:', error);
      return { total: 0, open: 0, closed: 0, inProgress: 0 };
    }
  }

  // Admin functions
  static async getAllTickets(): Promise<SupportTicket[]> {
    try {
      const { data, error } = await supabase
        .from('support_tickets')
        .select('*')
        .order('created_at', { ascending: false });

      if (error) throw error;

      return (data || []) as SupportTicket[];
    } catch (error) {
      console.error('Error fetching all tickets:', error);
      return [];
    }
  }

  static async updateTicketStatus(ticketId: string, status: SupportTicket['status'], assignedTo?: string): Promise<{ success: boolean; error?: string }> {
    try {
      const updateData: any = {
        status,
        updated_at: new Date().toISOString()
      };

      if (assignedTo) {
        updateData.assigned_to = assignedTo;
      }

      if (status === 'closed') {
        updateData.closed_at = new Date().toISOString();
      }

      const { error } = await supabase
        .from('support_tickets')
        .update(updateData)
        .eq('id', ticketId);

      if (error) throw error;

      return { success: true };
    } catch (error: any) {
      console.error('Error updating ticket status:', error);
      return { success: false, error: error.message };
    }
  }

  static async sendAdminMessage(messageData: SendMessageData, adminInfo: { id: string, name: string }): Promise<{ success: boolean; message?: SupportMessage; error?: string }> {
    try {
      const { data, error } = await supabase
        .from('support_messages')
        .insert({
          ticket_id: messageData.ticket_id,
          sender_id: adminInfo.id,
          sender_name: adminInfo.name,
          sender_type: 'admin',
          message: messageData.message
        })
        .select()
        .single();

      if (error) throw error;

      // Automatically update ticket status to in_progress if it's currently open
      await supabase
        .from('support_tickets')
        .update({
          status: 'in_progress',
          updated_at: new Date().toISOString()
        })
        .eq('id', messageData.ticket_id)
        .eq('status', 'open');

      return { success: true, message: data as SupportMessage };
    } catch (error: any) {
      console.error('Error sending admin message:', error);
      return { success: false, error: error.message };
    }
  }
}